// Command pgsema-gen generates Go code from PostgreSQL source files.
// Currently it generates:
// - keywords.go from kwlist.h
// - node types from parsenodes.h (TODO)
package main

import (
	"bufio"
	"flag"
	"fmt"
	"os"
	"regexp"
	"strings"
)

var (
	kwlistPath = flag.String("kwlist", "", "path to PostgreSQL kwlist.h")
	outDir     = flag.String("outdir", "pkg/parser", "output directory")
)

func main() {
	flag.Parse()

	if *kwlistPath != "" {
		if err := generateKeywords(*kwlistPath, *outDir); err != nil {
			fmt.Fprintf(os.Stderr, "Error generating keywords: %v\n", err)
			os.Exit(1)
		}
		fmt.Println("Generated keywords.go")
	}
}

// KeywordCategory represents the PostgreSQL keyword category.
type KeywordCategory int

const (
	UnreservedKeyword KeywordCategory = iota
	ColNameKeyword
	TypeFuncNameKeyword
	ReservedKeyword
)

// Keyword represents a PostgreSQL keyword.
type Keyword struct {
	Name     string          // keyword text (lowercase)
	Token    string          // token name in grammar
	Category KeywordCategory
	BareLable bool           // can be used as bare label
}

func generateKeywords(kwlistPath, outDir string) error {
	keywords, err := parseKwlist(kwlistPath)
	if err != nil {
		return err
	}

	outPath := outDir + "/keywords.go"
	f, err := os.Create(outPath)
	if err != nil {
		return err
	}
	defer f.Close()

	// Write header
	fmt.Fprintln(f, "// Code generated by pgsema-gen. DO NOT EDIT.")
	fmt.Fprintln(f, "// Source: PostgreSQL kwlist.h")
	fmt.Fprintln(f, "")
	fmt.Fprintln(f, "package parser")
	fmt.Fprintln(f, "")

	// Write KeywordCategory type
	fmt.Fprintln(f, "// KeywordCategory represents the PostgreSQL keyword category.")
	fmt.Fprintln(f, "type KeywordCategory int")
	fmt.Fprintln(f, "")
	fmt.Fprintln(f, "const (")
	fmt.Fprintln(f, "\tUnreservedKeyword KeywordCategory = iota")
	fmt.Fprintln(f, "\tColNameKeyword")
	fmt.Fprintln(f, "\tTypeFuncNameKeyword")
	fmt.Fprintln(f, "\tReservedKeyword")
	fmt.Fprintln(f, ")")
	fmt.Fprintln(f, "")

	// Write token constants
	fmt.Fprintln(f, "// Token constants for keywords.")
	fmt.Fprintln(f, "// These must match the values used in gram.y.")
	fmt.Fprintln(f, "const (")
	fmt.Fprintln(f, "\t// Base token value for keywords (must be > 256 to avoid ASCII conflicts)")
	fmt.Fprintln(f, "\tkeywordTokenBase = 258")
	fmt.Fprintln(f, "")
	for i, kw := range keywords {
		fmt.Fprintf(f, "\t%s = keywordTokenBase + %d\n", kw.Token, i)
	}
	fmt.Fprintln(f, ")")
	fmt.Fprintln(f, "")

	// Write Keyword struct
	fmt.Fprintln(f, "// Keyword represents a PostgreSQL keyword.")
	fmt.Fprintln(f, "type Keyword struct {")
	fmt.Fprintln(f, "\tName     string")
	fmt.Fprintln(f, "\tToken    int")
	fmt.Fprintln(f, "\tCategory KeywordCategory")
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f, "")

	// Write keyword list
	fmt.Fprintln(f, "// Keywords is the list of all PostgreSQL keywords.")
	fmt.Fprintln(f, "// The list is sorted by keyword name for binary search.")
	fmt.Fprintln(f, "var Keywords = []Keyword{")
	for _, kw := range keywords {
		catName := "UnreservedKeyword"
		switch kw.Category {
		case ColNameKeyword:
			catName = "ColNameKeyword"
		case TypeFuncNameKeyword:
			catName = "TypeFuncNameKeyword"
		case ReservedKeyword:
			catName = "ReservedKeyword"
		}
		fmt.Fprintf(f, "\t{%q, %s, %s},\n", kw.Name, kw.Token, catName)
	}
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f, "")

	// Write keyword lookup map
	fmt.Fprintln(f, "// keywordMap maps keyword names to their definitions.")
	fmt.Fprintln(f, "var keywordMap = func() map[string]*Keyword {")
	fmt.Fprintln(f, "\tm := make(map[string]*Keyword, len(Keywords))")
	fmt.Fprintln(f, "\tfor i := range Keywords {")
	fmt.Fprintln(f, "\t\tm[Keywords[i].Name] = &Keywords[i]")
	fmt.Fprintln(f, "\t}")
	fmt.Fprintln(f, "\treturn m")
	fmt.Fprintln(f, "}()")
	fmt.Fprintln(f, "")

	// Write lookup function
	fmt.Fprintln(f, "// LookupKeyword looks up a keyword by name (case-insensitive).")
	fmt.Fprintln(f, "// Returns nil if not found.")
	fmt.Fprintln(f, "func LookupKeyword(name string) *Keyword {")
	fmt.Fprintln(f, "\treturn keywordMap[strings.ToLower(name)]")
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f, "")

	// Need to add strings import
	// Re-read and add import
	return addImport(outPath, "strings")
}

func parseKwlist(path string) ([]Keyword, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	// PG_KEYWORD("abort", ABORT_P, UNRESERVED_KEYWORD, BARE_LABEL)
	re := regexp.MustCompile(`PG_KEYWORD\("([^"]+)",\s*(\w+),\s*(\w+),\s*(\w+)\)`)

	var keywords []Keyword
	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := scanner.Text()
		matches := re.FindStringSubmatch(line)
		if matches == nil {
			continue
		}

		name := matches[1]
		token := matches[2]
		catStr := matches[3]
		// bareLabel := matches[4] // not used for now

		var cat KeywordCategory
		switch catStr {
		case "UNRESERVED_KEYWORD":
			cat = UnreservedKeyword
		case "COL_NAME_KEYWORD":
			cat = ColNameKeyword
		case "TYPE_FUNC_NAME_KEYWORD":
			cat = TypeFuncNameKeyword
		case "RESERVED_KEYWORD":
			cat = ReservedKeyword
		default:
			return nil, fmt.Errorf("unknown keyword category: %s", catStr)
		}

		keywords = append(keywords, Keyword{
			Name:     name,
			Token:    token,
			Category: cat,
		})
	}

	return keywords, scanner.Err()
}

func addImport(path, pkg string) error {
	content, err := os.ReadFile(path)
	if err != nil {
		return err
	}

	// Find "package parser" line and add import after it
	lines := strings.Split(string(content), "\n")
	var result []string
	for i, line := range lines {
		result = append(result, line)
		if strings.HasPrefix(line, "package ") {
			// Add import after package line
			result = append(result, "")
			result = append(result, fmt.Sprintf("import %q", pkg))
			// Skip the existing empty line if any
			if i+1 < len(lines) && lines[i+1] == "" {
				continue
			}
		}
	}

	return os.WriteFile(path, []byte(strings.Join(result, "\n")), 0644)
}
